#!/bin/bash -e
# rc - remote control w/ ssh, for general-purpose task and job automation

RCDIR=$(dirname `readlink -f $0`)
RCROOT=$(dirname $RCDIR)

RCSSHOPTS="-o ConnectTimeout=5"

# We want RCSITE in environment to supersede a configured value
[ -n "$RCSITE" ] && RCSAVESITE=$RCSITE
[ -e ~/.rcconfig ] && source ~/.rcconfig
[ -n "$RCSAVESITE" ] && RCSITE="$RCSAVESITE"

# Default temporary script dir to $HOME if unconfigured, probably just for
# bootstrapping (install). Since CentOS7 and presumably other distros
# harden /tmp and /var/tmp, you can't create executables there.
RCSCRIPTTMPDIR=${RCSCRIPTTMPDIR:-$HOME}
RCRESUMEDIR=${RCRESUMEDIR:-/var/tmp}

# Functions for dealing with errors
. $RCROOT/libslocal/errhandle.sh
errtrap
# Functions for resolving supplied hosts
. $RCROOT/libslocal/hostlib.sh
# For looking up a task
. $RCROOT/libslocal/tasklib.sh
# For running/continuing jobs
. $RCROOT/libslocal/jobapi.sh
. $RCROOT/libslocal/joblib.sh
# Other rc functions that may be useful for jobs
. $RCROOT/libslocal/common.sh

# Try to figure out the site to use
if [ -z "$RCSITE" ] # environment variable overrides ~/.rcsite
then
	# If there's only one site, default to that
	RCSITECOUNT=$(ls $RCROOT/sites | wc -l)
	if [ $RCSITECOUNT -eq 1 ]
	then
		RCSITE=$(ls $RCROOT/sites)
	else
		RCSITE="FooBarBaz" # This makes other coding a little less painful.
		# In practice it just means more failed tests in rc's search paths
	fi
fi

# Default options - override rc.tasks
# Every script should give a usage statement
# when called with '-h'
RCSCRIPTOPTS=":h"
# By default, task scripts require at least zero arguments
RCREQUIREDARGS=0

# Options string for rc
RCOPTS=":cd:DE:hH:o:ps:St"
usage(){
	cat >&2 <<EOF
Usage:
rc - Run a remote shell script/command over ssh on one or more hosts,
	 optionally with elevated privileges.

rc list sites
	List all sites
rc list tasks (<site>|user)
	List tasks
rc list hostgroups
	List hostgroups for the current site
rc list hostgroup <group>
	List all hosts in group <group>
rc list jobs (site)
	List all jobs for the current or specified site

rc cmd (options) "<command>" (hostspec)
	Run a single command

rc resume <jobid> ("var=value" ...)

rc run (options) <job> (help | "var=value" ...)
	Run a job with the given variables (which may override defaults)

rc do (options) <task> (taskoptions) (taskarguments) (hostspec)
	<task> is the name of the task to be run, e.g. 'whois'

	(hostspec) is required for commands or if there is no default hostspec
		for the task. It can be a single host (or alias), hostgroup, or
		a space-separated combination of hosts, aliases and hostgroups
		enclosed in quotes.

	(options)
		-c
			(jobs only) Require confirmation before job runs
		-d <file>
			Specify a .defs file that is evaluated after any/all
			configured definitions file (for jobs and tasks)
		-D
			dry-run, echo the output to be sent but don't send (tasks)
		-h (task)
			print this help message or task help
		-H <host> | "<host> <host> ..." | @HOSTGROUP
			Override a default hostspec for a task
		-E (lib ... lib)
			Don't send remote libraries, e.g. -E errtrap.sh
		-o <dir>
			Send output from task to <dir>/<hostname>.out
		-p
			(jobs only) prompt user for all vars
		-s <site>
			Use <site>
		-S
			Run multiple hosts in serial (default parallel)
		-t
			Set trace debugging during task/job execution
	(taskoptions)
		'-h' will give usage for the task
	(arguments) are any arguments required by the task
EOF
	exit 1
}

[ $# -eq 0 ] && usage

taskhelp(){
	gettaskconf $1
	if [ -n "$RCSCRIPTPATH" ]
	then
		exec $RCSCRIPTPATH -h
	else
		echo "Help not available for $1"
		exit 0
	fi
}

# rcdo -> rc do, etc.
[ "$(basename $0)" = "rcdo" ] && set -- do "$@"
[ "$(basename $0)" = "rcrun" ] && set -- run "$@"
[ "$(basename $0)" = "rclist" ] && set -- list "$@"
[ "$(basename $0)" = "rccmd" ] && set -- cmd "$@"
if [[ $1 != -* ]]
then
	RCSUBCMD=$1
	shift
fi

# Loop through once to find command/task, process non-override options
while getopts "$RCOPTS" OPT
do
case $OPT in
	c)
		RCREQUIRECONFIRM="true"
		RCCONFIRMCODE=$(generateid)
		;;
	h)
		shift $((OPTIND - 1))
		if [ -n "$1" ]
		then
			taskhelp $1
		else
			usage
		fi
		;;
	d)
		RCDEFSFILE=${OPTARG}
		[ ! -e "$RCDEFSFILE" ] && errorout "Unable to locate definitions file $RCDEFSFILE"
		;;
	D)
		RCDRYRUN=true
		;;
	o)
		if [ ! -d ${OPTARG} ]
		then
			errorout "Directory ${OPTARG} doesn't exist"
		fi
		RCOUTPUTDIR=${OPTARG}
		;;
	p)
		RCPROMPT="true"
		;;
	s)
		RCSITE=${OPTARG}
		if [ ! -d "$RCROOT/sites/$RCSITE" ]
		then
			errorout "RCSITE ($RCSITE) refers to non-existent directory ($RCROOT/sites/$RCSITE)"
		fi
		;;
	S)
		RCSERIAL=true
		;;
	t)
		RCTRACE=true
		;;
	:)
		echo "Option -$OPTARG requires an argument." >&2
		usage
		;;
	\?)
		echo "Invalid option: -$OPTARG" >&2
		usage
		;;
esac
done

[ -e $RCROOT/sites/$RCSITE/rc.conf ] && source $RCROOT/sites/$RCSITE/rc.conf

# Get the args, up to three
RCARGNUM1=$OPTIND
RCARGNUM2=$((OPTIND + 1))
RCARGNUM3=$((OPTIND + 2))
RCARG1=${!RCARGNUM1}
RCARG2=${!RCARGNUM2}

case $RCSUBCMD in
	cmd)
		[ -z "$RCARG1" ] && errorout "missing command"
		RCCOMMAND="$RCARG1"
		[ -z "$RCARG2" ] && errorout "missing hostspec"
		resolvehostlist $RCARG2
		[ -n "$RCEXECHOSTS" ] || errorout "Unable to resolve any hosts from \"$RCARG2\""
		RCSHIFT=2
		;;
	run|resume)
		if [ "$RCSUBCMD" = "run" ]
		then
			RCJOB=$RCARG1
			RCJOBID=$(generateid)
			# Read in configured default values on first run
			# Note that .rcconfig has already been sourced, message here is for informational purposes
			[ -e ~/.rcconfig ] && echo "Sourcing ~/.rcconfig"
			# Locate the job script
			for RCJOBDIR in sites/$RCSITE sites/common defaultsite
			do
				RCJOBSCRIPT="$RCROOT/$RCJOBDIR/jobs/$RCJOB"
				if [ -e "$RCJOBSCRIPT" ]
				then
					RCDEFSNAME="$RCJOB"
					RCCONFIGLINE=$(grep -h "^#RCCONFIG:" "$RCJOBSCRIPT" || :)
					[ -n "$RCCONFIGLINE" ] && eval ${RCCONFIGLINE#*:}
					for RCJOBDEFPATH in "$RCROOT/defaultsite" "$RCROOT/sites/common" "$RCROOT/sites/$RCSITE"
					do
						if [ -e "$RCJOBDEFPATH/jobdefs/${RCDEFSNAME}.defs" ]
						then
							echo "Sourcing $RCJOBDEFPATH/jobdefs/${RCDEFSNAME}.defs"
							source "$RCJOBDEFPATH/jobdefs/${RCDEFSNAME}.defs"
						fi
					done
					# Quick sanity check on first run: check vars that must be defined in a .defs file
					RCDEFLINE=$(grep -h "^#RCREQDEFS=" "$RCJOBSCRIPT" || :)
					[ -n "$RCDEFLINE" ] && eval ${RCDEFLINE#\#}
					for RCREQUIRE in $RCREQDEFS
					do
						if [ -z "${!RCREQUIRE}" ]
						then
							RCALLMET="false"
							errormsg "Required definition $RCREQUIRE not defined"
						fi
					done
					if [ "$RCALLMET" = "false" ]
					then
						errorout "Missing definitions must be defined in a .defs file"
					fi
					break
				fi
			done
			[ -z "$RCJOBSCRIPT" ] && errorout "Job \"$RCJOB\" not found, maybe it's just a task?"
		else
			RCJOBID=$RCARG1
			[[ $RCARG2 = CONFIRM=* ]] && RCCONFIRMED=${RCARG2#*=}
			[ ! -e "$RCRESUMEDIR/rc-resume-${RCJOBID}.defs" ] && errorout "Couldn't resume $RCJOBID, file not found: \"$RCRESUMEDIR/rc-resume-${RCJOBID}.defs\""
			source "$RCRESUMEDIR/rc-resume-${RCJOBID}.defs"
		fi
		# For a job, a defs file can be pre-populated with job var definitions; these override all but options provided on the CLI
		[ -e "$RCDEFSFILE" ] && source "$RCDEFSFILE"
		# shift away rc options and arguments, the rest go to the job
		shift $((OPTIND))
		if [ "$1" != "help" -a "$1" != "-h" ]
		then
			for RCJOBVAR in "$@"
			do
				eval "$RCJOBVAR"
			done
		else
			RCJOBHELP="help"
		fi
		export RCROOT RCSITE RCJOBID RCJOB RCJOBSCRIPT
		[ -z "$RCJOBHELP" ] && writeresumefile "$RCJOBSCRIPT"
		if [ -z "$RCDRYRUN" ]
		then
			RCJOBTMP=$(mktemp $RCROOT/scripts/rcjob-XXXXXX.sh)
			catjob "$RCJOBSCRIPT" $RCJOBHELP > $RCJOBTMP
			chmod u+x $RCJOBTMP
			exec $RCJOBTMP
		else
			echo "*** DRY RUN ***" >&2
			catjob "$RCJOBSCRIPT" $RCJOBHELP
			rm -f "$RCRESUMEDIR/${RCJOBID}.defs"
		fi
		exit $?
		;;
	list)
		[ -z "$RCARG1" ] && errorout "Missing argument to list command"
		case "$RCARG1" in
			jobs)
				RCSITE=${RCARG2:-$RCSITE}
				for SITE in "sites/$RCSITE" sites/common defaultsite
				do
					RCJOBLIST=$(ls -A $RCROOT/$SITE/jobs/ 2>/dev/null || :)
					[ -n "$RCJOBLIST" ] && echo -e "### Jobs for $SITE:\n$RCJOBLIST"
				done
				exit 0
				;;
			tasks)
				[ -e ~/.tasks.conf -a \( -z "$RCARG2" -o "$RCARG2" = "user" \) ] && { echo "### User tasks:"; grep -v "^#" ~/.tasks.conf | grep -v '^$'; }
				[ "$RCARG2" = "user" ] && exit 0
				listsitetasks $RCARG2
				[ -n "$RCARG2" ] && exit 0
				listsitetasks common
				listsitetasks defaultsite
				exit 0
				;;
			sites)
				ls -d $RCROOT/sites/* | xargs basename -a
				exit 0
				;;
			hostgroups)
				[ -n "$(ls -A $RCROOT/sites/$RCSITE/hostgroups)" ] && \
					ls -d $RCROOT/sites/$RCSITE/hostgroups/* | xargs basename -s .hosts
				exit 0
				;;
			hostgroup)
				[ -z "$RCARG2" ] && errorout "Missing group name to list hostgroup command"
				resolvehostgroup $RCARG2
				[ -n "$RCEXECHOSTS" ] || errorout "Unable to resolve any hosts from group \"$RCARG2\""
				for RCHOST in $RCEXECHOSTS
				do
					hostnicename $RCHOST
					echo "$RCNICENAME -> $RCHOST"
				done
				exit 0
				;;
			*)
				errorout "Don't know how to list $RCARG1"
				;;
		esac
		;;
	do)
		RCTASKNAME=$RCARG1
		# Special case: handle rc <task> -h
		[ "$RCARG2" = "-h" ] && taskhelp $RCTASKNAME
		# Get task defaults
		if [ -n "$RCTASKNAME" ]
		then
			gettaskconf $RCTASKNAME
		fi
		# For a task, a defs file can override configured vars for a task
		[ -e "$RCDEFSFILE" ] && source "$RCDEFSFILE"
		# Resolve remote hosts
		if [ -n "$RCEXECHOSTS" ]
		then
			RCRESOLVEHOSTS="$RCEXECHOSTS"
			unset RCEXECHOSTS
			resolvehostlist $RCRESOLVEHOSTS
			[ -n "$RCEXECHOSTS" ] || errorout "Couldn't resolve any hosts from configured hostlist \"$RCRESOLVEHOSTS\""
		else # If there was no default, last argument needs to be the host spec
			# Create an array from the positional parameters
			RCARGARR=("$@")
			# Resolve hosts from the last element
			resolvehostlist ${RCARGARR[-1]}
			[ -n "$RCEXECHOSTS" ] || errorout "Couldn't resolve any hosts from \"${RCARGARR[-1]}\""
			# Remove the last element
			((RCLASTARG=${#RCARGARR[@]} - 1))
			unset -v RCARGARR[$RCLASTARG]
			# Re-set the positional parameters
			set -- "${RCARGARR[@]}"
		fi
		RCSHIFT=1
		;;
	*)
		errormsg "Unknown command: $RCSUBCMD"
		usage
		;;
esac

# Rewind for full option processing
OPTIND=1

# Now process options for rc, which can override defaults from ~/.tasks.conf
while getopts "$RCOPTS" OPT
do
	case $OPT in
		E)
			RCEXCLUDELIBS="$RCEXCLUDELIBS ${OPTARG}"
			;;
		H)
			resolvehostlist ${OPTARG}
			[ -n "$RCEXECHOSTS" ] || errorout "Couldn't resolve any hosts from \"${OPTARG}\""
			;;
		-)
			break
			;;
	esac
done

# Shift away rc options and taskname
shift $((OPTIND - 1))
# Shift away arguments; remaining options and args
# are for the task
shift $RCSHIFT

if [ -n "$RCSCRIPT" ] # Processing for an RCSCRIPT
then
	# Cycle through the task options so we can check # of args
	while getopts "$RCSCRIPTOPTS" OPT
	do
		[ "$OPT" = "h" ] && exec $RCSCRIPTPATH -h
	done
	ARGS=$(($# - (OPTIND - 1) ))
	# If not enough args given, display usage
	[ $# -lt $RCREQUIREDARGS ] && exec $RCSCRIPTPATH -h
else # RCCOMMAND, not RCSCRIPT
	if [ $# -lt $RCREQUIREDARGS ]
	then
		errorout "$RCCOMMAND requires at least $RCREQUIREDARGS argument(s)"
	fi
fi

[ -z "$RCEXECHOSTS" ] && errorout "No remote host set!"

# Create the SETSTRING for passing arguments to the remote host
if [ $# -gt 0 -a -z "$RCCOMMAND" ]
then
	SETSTRING="set -- \"$1\""
	shift
	while [ -n "$1" ]
	do
		SETSTRING="$SETSTRING \"$1\""
		shift
	done
fi

# Get a password for sudo if required
if [ "$RCELEVATE" = "true" -a -z "$RCDRYRUN" ]
then
	# Try reading from RCPASSPIPE first
	if [ "${RCELEVATETYPE:=SUDOPASS}" = "SUDOPASS" ]
	then
		if [ -n "$RCPASSPIPE" ]
		then
			[ ! -e "$RCPASSPIPE" ] && mkfifo -m 0600 "$RCPASSPIPE" || :
			while [ -z "$RCSUDOPASS" ]
			do
				read -t 1 RCSUDOPASS <> "$RCPASSPIPE" || $RCROOT/scripts/passdaemon
			done
		fi
		if [ -z "$RCSUDOPASS" ]
		then
			echo -n "Password for sudo:"
			read -s RCSUDOPASS
			echo
		fi
	fi
fi

# Piper generates the input to ssh, which amounts to a shell script run
# in immediate mode
piper(){
	local RCHOST=$1
	local RCTASK=$2
	shift 2
	# If we're sudo'ing, take care of that first
	if [ -n "$RCELEVATE" ]
	then
		case $RCELEVATETYPE in
			SUDOPASS)
				# To supply a sudo password we have to jump through some hoops
				# with a very temporary sudo askpass helper script
				RCASKPASS=rc-helper-$(date | md5sum | cut -f 1 -d' ').sh
				echo "export SUDO_ASKPASS=\$HOME/$RCASKPASS"
				echo "echo '#!/bin/bash' > \$HOME/$RCASKPASS"
				[ -n "$RCDRYRUN" ] && echo "RCSUDOPASS=\"echo <password>\""
				if [ -z "$RCDRYRUN" ]
				then
					[ -n "$RCTRACE" ] && echo "set +x"
					echo "RCSUDOPASS=\"echo $RCSUDOPASS\""
					[ -n "$RCTRACE" ] && echo "set -x"
				fi
				cat $RCROOT/libsremote/sudosetup.sh
				# This will fail if user's $HOME != /home/$SUDO_USER
				# but the file will be removed below after sudo exits
				echo "rm -f /home/\$SUDO_USER/$RCASKPASS"
				;;
			SUDONOPASS)
				# When there's no password required, we just sudo su
				echo "sudo su <<\"RCSUDOSCRIPTEOF\""
				;;
			ROOTLOGIN)
				unset RCELEVATE # so we don't bother closing sudo later
				;;
		esac
	fi
	echo "set -e"
	RCTASKID=$(generateid)
	[ -n "$RCTRACE" ] && echo "set -x"
	# Set the task ID
	echo "RCTASKID=$RCTASKID"
	# Send libraries for remote use
	for RCREMOTELIB in errtrap.sh status.sh
	do
		if ! echo " $RCEXCLUDELIBS " | grep -q " $RCREMOTELIB "
		then
			cat $RCROOT/libsremote/$RCREMOTELIB
		fi
	done
	# Send variable definitions
	taskdefs $RCHOST $RCTASK
	# Set the positional values, options and arguments
	[ -n "$SETSTRING" ] && echo "$SETSTRING" || :
	echo "echo $RCTASKID task starting on $RCHOST: $(basename $RCSCRIPT) >&2"
	# Make note of the line before the script starts
	echo "RCFIRSTLINE=\$LINENO"
	# Finally, run the task
	cat $RCSCRIPTPATH
	# Close the sudo verbatim heredoc started in sudosetup.sh
	if [ -n "$RCSUDOPASS" ]
	then
		echo "RCSUDOSCRIPTEOF"
		echo "RETVAL=\$?"
		echo "rm -f \$HOME/$RCASKPASS"
		echo "exit \$RETVAL"
	fi
}

# Should output go to files?
RCHOSTARRAY=($RCEXECHOSTS)
RCNUMHOSTS=${#RCHOSTARRAY[@]}
if [ -n "$RCOUTPUTDIR" -o \( $RCNUMHOSTS -gt 1 -a -z "$RCSERIAL" \) ]
then
	if [ -n "$RCOUTPUTDIR" ]
	then
		[ ! -d "$RCOUTPUTDIR" ] && errorout "Output dir $RCOUTPUTDIR doesn't exist"
		RCOUTPUTDIR=${RCOUTPUTDIR%/}
	else
		RCTEMPDIR=true
		RCOUTPUTDIR=$(mktemp -d /tmp/rcout-XXXXXX)
	fi
	echo "Output will be logged to $RCOUTPUTDIR/<host>.(out|err)"
	[ -z "$RCSERIAL" -a $RCNUMHOSTS -gt 1 ] && RCPARALLEL=true # multiple hosts, run in background
fi

hosterrorcheck(){
	RCRETVAL=$?
	# Turn error trapping back on
	set -e
	trap 'error_handler "${BASH_COMMAND}" ${LINENO} $?' ERR
	if [ $RCRETVAL -ne 0 ]
	then
		if [ $RCRETVAL -eq 255 ]
		then
			echo "ssh process exited with error connecting to $RCREMOTE, exit code:255" >&2
		else
			[ -z "$RCPARALLEL" ] && echo "Remote host $RCREMOTE exited with error code:$RCRETVAL" >&2
		fi
		if [ $RCNUMHOSTS -eq 1 ]
		then
			# If we're operating on a single host and it fails,
			# exit with the same error code.
			trap - ERR
			exit $RCRETVAL
		fi
	fi
	return $RCRETVAL
}

[ -z "$RCTASKNAME" ] && RCTASKNAME="$RCCOMMAND" || :
for RCREMOTE in $RCEXECHOSTS
do
	hostnicename $RCREMOTE
	if [ -n "$RCDRYRUN"  ]
	then
		echo "*** DRY RUN ***" >&2
		echo "*** Sending \"$RCTASKNAME\" to $RCNICENAME" >&2
		[ -n "$RCCOMMAND" ] && echo "$RCCOMMAND $*"
		[ -n "$RCSCRIPT" ] && piper $RCNICENAME $RCTASKNAME $*
	else
		echo "*** Sending \"$RCTASKNAME\" to $RCNICENAME" >&2
		# Don't error out or trap if ssh returns an error
		set +e
		trap - ERR
		# Send the script to the remote host over ssh
		if [ -n "$RCPARALLEL" ]
		then
			if [ -n "$RCSCRIPT" ]
			then
				piper $RCNICENAME $RCTASKNAME $* | (
					ssh $RCSSHOPTS -T $RCREMOTE > $RCOUTPUTDIR/$RCREMOTE.out 2> $RCOUTPUTDIR/$RCREMOTE.err
					hosterrorcheck
				) &
				RCWAITTASKS="$RCWAITTASKS $!:$RCNICENAME"
			else
				(	ssh $RCSSHOPTS -T $RCREMOTE "$RCCOMMAND $*" > $RCOUTPUTDIR/$RCREMOTE.out 2> $RCOUTPUTDIR/$RCREMOTE.err
					hosterrorcheck
				) &
				RCWAITTASKS="$RCWAITTASKS $!:$RCNICENAME"
			fi
			# Turn error trapping back on
			set -e
			trap 'error_handler "${BASH_COMMAND}" ${LINENO} $?' ERR
		else
			if [ -z "$RCOUTPUTDIR" ]
			then
				[ -n "$RCSCRIPT" ] && { piper $RCNICENAME $RCTASKNAME $* | ssh $RCSSHOPTS -T $RCREMOTE; hosterrorcheck; }
				[ -n "$RCCOMMAND" ] && { ssh $RCSSHOPTS -T $RCREMOTE "$RCCOMMAND $*"; hosterrorcheck; }
			else
				[ -n "$RCSCRIPT" ] && { piper $RCNICENAME $RCTASKNAME $* | ssh $RCSSHOPTS -T $RCREMOTE > $RCOUTPUTDIR/$RCREMOTE.out 2> $RCOUTPUTDIR/$RCREMOTE.err; hosterrorcheck; }
				[ -n "$RCCOMMAND" ] && { ssh $RCSSHOPTS -T $RCREMOTE "$RCCOMMAND $*" > $RCOUTPUTDIR/$RCREMOTE.out 2> $RCOUTPUTDIR/$RCREMOTE.err; hosterrorcheck; }
			fi
		fi
	fi
done
if [ -n "$RCPARALLEL" ]
then
	RCSUCCEEDED=0
	RCFAILED=0
	echo "... waiting for all hosts to finish"
	for RCWAITTASKSPEC in $RCWAITTASKS
	do
		RCWAITTASK="${RCWAITTASKSPEC%:*}"
		RCWAITHOST="${RCWAITTASKSPEC#*:}"
		set +e
		trap - ERR
		wait $RCWAITTASK
		RCHOSTRETVAL=$?
		set -e
		trap 'error_handler "${BASH_COMMAND}" ${LINENO} $?' ERR
		if [ $RCHOSTRETVAL = 0 ]
		then
			RCSUCCEEDED=$((RCSUCCEEDED + 1))
		else
			RCFAILED=$((RCFAILED + 1))
			errormsg "host $RCWAITHOST returned $RCHOSTRETVAL"
		fi
	done
	echo "Done. $RCSUCCEEDED hosts succeeded, $RCFAILED failed."
fi

# this space intentionally left blank
